<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿‘éŸ³è¯æœç´¢ - Phonetic Word Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 40px 30px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .search-section {
            padding: 40px 30px;
            background: #f8f9ff;
        }

        .search-container {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 15px 20px;
            border: 2px solid #e0e7ff;
            border-radius: 15px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.2);
        }

        .search-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        .search-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .result-section {
            padding: 0 30px 40px;
        }

        .phonetic-info {
            background: #fff;
            border: 2px solid #e0e7ff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            display: none;
        }

        .phonetic-info h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .phonetic-transcription {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .phonetic-transcription li {
            list-style: none;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .bold {
            font-weight: bold;
            color: #4facfe;
        }

        .syllables {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #4facfe;
        }

        .similar-words {
            display: none;
        }

        .similar-words h4 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .word-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 18px;
            border-radius: 25px;
            text-decoration: none;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .word-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            text-decoration: none;
            color: white;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
            border-left: 4px solid #c33;
        }

        .example-searches {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .example-searches h4 {
            margin-bottom: 15px;
            color: #333;
        }

        .example-tags {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .example-tag {
            background: white;
            color: #4facfe;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #4facfe;
        }

        .example-tag:hover {
            background: #4facfe;
            color: white;
        }

        @media (max-width: 768px) {
            .search-container {
                flex-direction: column;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .word-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” è¿‘éŸ³è¯æœç´¢</h1>
            <p>Phonetic Word Finder - å‘ç°å‘éŸ³ç›¸ä¼¼çš„è‹±è¯­å•è¯</p>
        </div>

        <div class="search-section">
            <div class="example-searches">
                <h4>ğŸš€ è¯•è¯•è¿™äº›ç¤ºä¾‹ï¼š</h4>
                <div class="example-tags">
                    <span class="example-tag" onclick="searchExample('cognitive')">cognitive</span>
                    <span class="example-tag" onclick="searchExample('conductive')">conductive</span>
                    <span class="example-tag" onclick="searchExample('productive')">productive</span>
                    <span class="example-tag" onclick="searchExample('creative')">creative</span>
                    <span class="example-tag" onclick="searchExample('support')">support</span>
                </div>
            </div>

            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="è¾“å…¥è‹±è¯­å•è¯..." />
                <button class="search-btn" onclick="searchSimilarWords()">æœç´¢è¿‘éŸ³è¯</button>
            </div>

            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="result-section">
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
                <p>æ­£åœ¨æœç´¢è¿‘éŸ³è¯...</p>
            </div>

            <div class="phonetic-info" id="phoneticInfo">
                <h3>ğŸ“ éŸ³æ ‡ä¿¡æ¯</h3>
                <ul class="phonetic-transcription" id="phoneticTranscription">
                </ul>
            </div>

            <div class="similar-words" id="similarWords">
                <h4>ğŸ¯ å‘éŸ³ç›¸ä¼¼çš„å•è¯ï¼š</h4>
                <div class="word-grid" id="wordGrid"></div>
            </div>
        </div>
    </div>

    <script>
        // é¢„å®šä¹‰çš„éŸ³æ ‡æ•°æ®åº“ï¼ˆæ‰©å±•ç‰ˆï¼‰
        const phoneticDatabase = {
            'cognitive': {
                modern: 'ËˆkÉ’É¡nÉªtÉªv',
                traditional: 'ËˆkÉ’É¡nÉªtÉªv',
                syllables: ['COG', 'ni', 'tive'],
                similar: ['connective', 'collective', 'corrective', 'protective', 'selective', 'detective', 'objective', 'subjective', 'effective', 'directive']
            },
            'conductive': {
                modern: 'kÉ™nËˆdÊŒktÉªv',
                traditional: 'kÉ™nËˆdÊŒktÉªv',
                syllables: ['con', 'DUC', 'tive'],
                similar: ['productive', 'destructive', 'constructive', 'instructive', 'reductive', 'inductive', 'deductive', 'seductive', 'reproductive', 'counterproductive']
            },
            'productive': {
                modern: 'prÉ™ËˆdÊŒktÉªv',
                traditional: 'prÉ™ËˆdÊŒktÉªv',
                syllables: ['pro', 'DUC', 'tive'],
                similar: ['conductive', 'destructive', 'constructive', 'instructive', 'reductive', 'reproductive', 'counterproductive', 'unproductive']
            },
            'creative': {
                modern: 'kriËˆeÉªtÉªv',
                traditional: 'kriËˆeÉªtÉªv',
                syllables: ['cre', 'A', 'tive'],
                similar: ['innovative', 'initiative', 'decorative', 'comparative', 'narrative', 'operative', 'cooperative', 'collaborative', 'administrative', 'representative']
            },
            'effective': {
                modern: 'ÉªËˆfektÉªv',
                traditional: 'ÉªËˆfektÉªv',
                syllables: ['ef', 'FEC', 'tive'],
                similar: ['selective', 'collective', 'protective', 'objective', 'subjective', 'detective', 'corrective', 'directive', 'reflective', 'perspective']
            },
            'organization': {
                modern: 'ËŒÉ”ËÉ¡É™naÉªËˆzeÉªÊƒÉ™n',
                traditional: 'ËŒÉ”ËÉ¡É™naÉªËˆzeÉªÊƒÉ™n',
                syllables: ['OR', 'ga', 'ni', 'ZA', 'tion'],
                similar: ['organisation', 'organizations', 'organisations', 'organizational', 'reorganization', 'americanization', 'disorganization', 'ionization', 'organism', 'organizer', 'organizing', 'modernization', 'standardization', 'characterization', 'crystallization']
            },
            'support': {
                modern: 'sÉ™ËˆpÉ”Ët',
                traditional: 'sÉ™ËˆpÉ”Ët',
                syllables: ['suh', 'PORT'],
                similar: ['report', 'import', 'export', 'transport', 'deport', 'comfort', 'effort', 'sport', 'court', 'fort', 'sort', 'short', 'abort', 'distort', 'resort', 'consort', 'escort', 'supports', 'supporting', 'supported', 'supportive']
            }
        };

        // æ‰©å±•çš„è¯æ±‡åº“ç”¨äºåŒ¹é…
        const extendedVocabulary = [
            // support ç›¸å…³
            'support', 'supports', 'supporting', 'supported', 'supportive', 'unsupported',
            'report', 'reports', 'reporting', 'reported', 'reporter', 'import', 'imports',
            'export', 'exports', 'transport', 'transports', 'deport', 'comfort', 'effort',
            'sport', 'sports', 'port', 'ports', 'court', 'courts', 'fort', 'forts',
            'sort', 'sorts', 'short', 'abort', 'distort', 'resort', 'consort', 'escort',
            
            // organization ç›¸å…³
            'organization', 'organisation', 'organizations', 'organisations', 
            'organizational', 'reorganization', 'disorganization', 'organism',
            'organizer', 'organizing', 'organized', 'organic', 'organically',
            
            // -ation ç»“å°¾çš„è¯
            'nation', 'station', 'creation', 'education', 'information', 'formation', 
            'operation', 'population', 'preparation', 'presentation', 'communication', 
            'transportation', 'investigation', 'administration', 'registration', 
            'demonstration', 'recommendation', 'concentration', 'celebration', 'vacation',
            'relation', 'situation', 'location', 'invitation', 'motivation', 'inspiration',
            'americanization', 'modernization', 'standardization', 'characterization',
            'crystallization', 'ionization', 'civilization', 'realization', 'localization',
            'optimization', 'maximization', 'minimization', 'specialization', 'globalization',
            'privatization', 'digitization', 'urbanization', 'democratization', 'decentralization',
            
            // -tion ç»“å°¾çš„è¯
            'action', 'section', 'function', 'production', 'protection', 'construction',
            'destruction', 'instruction', 'attraction', 'reaction', 'interaction', 'transaction',
            'fraction', 'fiction', 'distinction', 'extinction', 'prediction', 'addiction',
            
            // -ive ç»“å°¾çš„è¯
            'active', 'passive', 'massive', 'native', 'creative', 'innovative', 'productive', 
            'effective', 'selective', 'collective', 'protective', 'objective', 'subjective', 
            'detective', 'corrective', 'directive', 'reflective', 'perspective', 'constructive',
            'destructive', 'instructive', 'conductive', 'reproductive', 'competitive',
            'alternative', 'relative', 'negative', 'positive', 'sensitive', 'expensive',
            'extensive', 'intensive', 'comprehensive', 'progressive', 'aggressive', 'impressive',
            'cognitive', 'decorative', 'comparative', 'narrative', 'operative', 'cooperative', 
            'collaborative', 'administrative', 'representative',
            
            // å¸¸è§å•è¯
            'important', 'different', 'available', 'possible', 'necessary', 'interesting',
            'difficult', 'beautiful', 'wonderful', 'successful', 'powerful', 'peaceful',
            'careful', 'helpful', 'useful', 'harmful', 'painful', 'grateful', 'faithful',
            'doubtful', 'hopeful', 'cheerful', 'respectful', 'forgetful', 'delightful',
            
            // åŠ¨è¯è¿‡å»å¼å’Œç°åœ¨åˆ†è¯
            'started', 'finished', 'worked', 'played', 'studied', 'visited', 'decided',
            'provided', 'included', 'considered', 'developed', 'happened', 'changed',
            'starting', 'finishing', 'working', 'playing', 'studying', 'visiting',
            'deciding', 'providing', 'including', 'considering', 'developing', 'happening',
            
            // å…¶ä»–å¸¸è§è¯æ±‡
            'computer', 'internet', 'website', 'software', 'hardware', 'database',
            'network', 'system', 'program', 'project', 'product', 'service', 'business',
            'company', 'industry', 'technology', 'science', 'research', 'development',
            'management', 'marketing', 'advertising', 'customer', 'market', 'economy'
        ];

        // æœç´¢ç›¸ä¼¼å‘éŸ³çš„å•è¯ - é›†æˆå¤šä¸ªAPI
        async function searchSimilarWords() {
            const searchInput = document.getElementById('searchInput');
            const word = searchInput.value.trim().toLowerCase();
            
            if (!word) {
                showError('è¯·è¾“å…¥ä¸€ä¸ªè‹±è¯­å•è¯');
                return;
            }

            // æ›´æ–°URL
            updateUrl(word);

            showLoading(true);
            hideError();

            try {
                // é¦–å…ˆæ£€æŸ¥æœ¬åœ°æ•°æ®åº“
                if (phoneticDatabase[word]) {
                    displayResults(word, phoneticDatabase[word]);
                } else {
                    // ä½¿ç”¨å¤šä¸ªå…è´¹APIæœç´¢
                    await searchFromMultipleAPIs(word);
                }
            } catch (error) {
                showError('æœç´¢è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');
                console.error('Search error:', error);
            } finally {
                showLoading(false);
            }
        }

        // ä½¿ç”¨å¤šä¸ªAPIæœç´¢
        async function searchFromMultipleAPIs(word) {
            try {
                const [dictionaryData, rhymeWords, similarSoundWords, synonyms] = await Promise.allSettled([
                    fetchDictionaryData(word),
                    fetchRhymingWords(word),
                    fetchSimilarSoundingWords(word),
                    fetchSynonyms(word)
                ]);

                // æ”¶é›†æ‰€æœ‰ç›¸ä¼¼è¯
                const allSimilarWords = [];
                
                if (rhymeWords.status === 'fulfilled') {
                    allSimilarWords.push(...rhymeWords.value);
                }
                if (similarSoundWords.status === 'fulfilled') {
                    allSimilarWords.push(...similarSoundWords.value);
                }
                if (synonyms.status === 'fulfilled') {
                    allSimilarWords.push(...synonyms.value);
                }

                // å¦‚æœAPIè¿”å›çš„è¯ä¸å¤Ÿï¼Œè¡¥å……æœ¬åœ°ç®—æ³•ç”Ÿæˆçš„è¯
                if (allSimilarWords.length < 10) {
                    const localWords = generateSimilarWords(word);
                    allSimilarWords.push(...localWords);
                }

                // è·å–éŸ³æ ‡ä¿¡æ¯
                let phonetic = null;
                let syllables = null;
                
                if (dictionaryData.status === 'fulfilled' && dictionaryData.value) {
                    phonetic = dictionaryData.value.phonetic;
                    syllables = dictionaryData.value.syllables;
                }

                // åˆ›å»ºç»“æœæ•°æ®
                const phoneticData = {
                    modern: phonetic || generatePhonetic(word),
                    traditional: phonetic || generatePhonetic(word),
                    syllables: syllables || generateSyllables(word),
                    similar: [...new Set(allSimilarWords)].filter(w => w !== word).slice(0, 20)
                };

                displayResults(word, phoneticData);

            } catch (error) {
                console.log('All APIs failed, using fallback:', error);
                // å®Œå…¨å›é€€åˆ°æœ¬åœ°ç®—æ³•
                await searchFromAPI(word);
            }
        }

        // æ¨¡æ‹ŸAPIæœç´¢ - ä½¿ç”¨çœŸå®çš„å…è´¹API
        async function searchFromAPI(word) {
            try {
                // ä½¿ç”¨Free Dictionary APIè·å–åŸºæœ¬ä¿¡æ¯
                const dictionaryData = await fetchDictionaryData(word);
                
                // ä½¿ç”¨WordsAPIè·å–ç›¸å…³è¯æ±‡
                const similarWords = await fetchSimilarWords(word);
                
                // ç”Ÿæˆè¯æ±‡æ•°æ®
                const phoneticData = {
                    modern: dictionaryData.phonetic || generatePhonetic(word),
                    traditional: dictionaryData.phonetic || generatePhonetic(word),
                    syllables: dictionaryData.syllables || generateSyllables(word),
                    similar: similarWords.length > 0 ? similarWords : generateSimilarWords(word)
                };

                displayResults(word, phoneticData);
            } catch (error) {
                console.log('API search failed, using fallback algorithm:', error);
                // å¦‚æœAPIå¤±è´¥ï¼Œå›é€€åˆ°åŸæœ‰ç®—æ³•
                const similarWords = generateSimilarWords(word);
                const phoneticData = {
                    modern: generatePhonetic(word),
                    traditional: generatePhonetic(word),
                    syllables: generateSyllables(word),
                    similar: similarWords
                };
                displayResults(word, phoneticData);
            }
        }

        // è·å–è¯å…¸æ•°æ®
        async function fetchDictionaryData(word) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) throw new Error('Dictionary API failed');
                
                const data = await response.json();
                if (data && data.length > 0) {
                    const entry = data[0];
                    return {
                        phonetic: entry.phonetic || (entry.phonetics && entry.phonetics[0] && entry.phonetics[0].text) || null,
                        syllables: extractSyllables(entry.phonetic || entry.word)
                    };
                }
            } catch (error) {
                console.log('Dictionary API error:', error);
                return { phonetic: null, syllables: null };
            }
        }

        // è·å–ç›¸ä¼¼è¯æ±‡
        async function fetchSimilarWords(word) {
            const similarWords = [];
            
            try {
                // æ–¹æ³•1: ä½¿ç”¨WordsAPI (éœ€è¦API keyï¼Œè¿™é‡Œç”¨å¤‡ç”¨æ–¹æ¡ˆ)
                // const wordsApiData = await fetchWordsAPI(word);
                // similarWords.push(...wordsApiData);
                
                // æ–¹æ³•2: åŸºäºDatamuse APIè·å–ç›¸ä¼¼å‘éŸ³çš„è¯
                const rhymeData = await fetchRhymingWords(word);
                similarWords.push(...rhymeData);
                
                // æ–¹æ³•3: åŸºäºå­—å…¸APIçš„åŒä¹‰è¯
                const synonymData = await fetchSynonyms(word);
                similarWords.push(...synonymData);
                
            } catch (error) {
                console.log('Similar words API error:', error);
            }
            
            // å»é‡å¹¶é™åˆ¶æ•°é‡
            return [...new Set(similarWords)].slice(0, 20);
        }

        // è·å–æŠ¼éŸµè¯
        async function fetchRhymingWords(word) {
            try {
                const response = await fetch(`https://api.datamuse.com/words?rel_rhy=${word}&max=10`);
                if (!response.ok) throw new Error('Rhyme API failed');
                
                const data = await response.json();
                return data.map(item => item.word);
            } catch (error) {
                console.log('Rhyme API error:', error);
                return [];
            }
        }

        // è·å–å‘éŸ³ç›¸ä¼¼çš„è¯
        async function fetchSimilarSoundingWords(word) {
            try {
                const response = await fetch(`https://api.datamuse.com/words?sl=${word}&max=15`);
                if (!response.ok) throw new Error('Similar sound API failed');
                
                const data = await response.json();
                return data.map(item => item.word);
            } catch (error) {
                console.log('Similar sound API error:', error);
                return [];
            }
        }

        // è·å–åŒä¹‰è¯
        async function fetchSynonyms(word) {
            try {
                // ä½¿ç”¨å…è´¹çš„è¯å…¸APIè·å–åŒä¹‰è¯
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) throw new Error('Synonym API failed');
                
                const data = await response.json();
                const synonyms = [];
                
                if (data && data.length > 0) {
                    data[0].meanings?.forEach(meaning => {
                        meaning.definitions?.forEach(definition => {
                            if (definition.synonyms) {
                                synonyms.push(...definition.synonyms);
                            }
                        });
                    });
                }
                
                return synonyms.slice(0, 10);
            } catch (error) {
                console.log('Synonym API error:', error);
                return [];
            }
        }

        // ä»éŸ³æ ‡æå–éŸ³èŠ‚
        function extractSyllables(phonetic) {
            if (!phonetic) return null;
            
            // ç®€å•çš„éŸ³èŠ‚åˆ†å‰²ï¼ˆåŸºäºé‡éŸ³ç¬¦å·ï¼‰
            const syllables = phonetic.split(/[ËˆËŒ]/).filter(s => s.length > 0);
            return syllables.length > 0 ? syllables : null;
        }

        // ç”ŸæˆéŸ³æ ‡ï¼ˆç®€åŒ–é€»è¾‘ï¼‰
        function generatePhonetic(word) {
            const vowelMap = {
                'a': 'Ã¦', 'e': 'É›', 'i': 'Éª', 'o': 'É’', 'u': 'ÊŒ'
            };
            
            let phonetic = '';
            for (let char of word) {
                if (vowelMap[char]) {
                    phonetic += vowelMap[char];
                } else {
                    phonetic += char;
                }
            }
            return phonetic;
        }

        // ç”ŸæˆéŸ³èŠ‚
        function generateSyllables(word) {
            const syllables = [];
            let currentSyllable = '';
            
            for (let i = 0; i < word.length; i++) {
                currentSyllable += word[i];
                if (isVowel(word[i]) && i < word.length - 1 && !isVowel(word[i + 1])) {
                    syllables.push(currentSyllable.toUpperCase());
                    currentSyllable = '';
                }
            }
            
            if (currentSyllable) {
                syllables.push(currentSyllable.toLowerCase());
            }
            
            return syllables.length > 0 ? syllables : [word.toUpperCase()];
        }

        function isVowel(char) {
            return 'aeiou'.includes(char.toLowerCase());
        }

        // ç”Ÿæˆç›¸ä¼¼å•è¯ - æ”¹è¿›çš„ç®—æ³•
        function generateSimilarWords(word) {
            const similar = [];
            
            // 1. ç›´æ¥å˜å½¢ï¼ˆå¤æ•°ã€è¿‡å»å¼ç­‰ï¼‰
            const directVariations = generateDirectVariations(word);
            similar.push(...directVariations);
            
            // 2. åŸºäºéŸ³éŸµæ¨¡å¼åŒ¹é…
            const phoneticMatches = findPhoneticMatches(word);
            similar.push(...phoneticMatches);
            
            // 3. è¯æ ¹ç›¸åŒçš„è¯
            const rootMatches = findRootMatches(word);
            similar.push(...rootMatches);
            
            // 4. éŸ³èŠ‚ç»“æ„ç›¸ä¼¼çš„è¯
            const syllableMatches = findSyllableMatches(word);
            similar.push(...syllableMatches);
            
            // å»é‡å¹¶é™åˆ¶æ•°é‡
            const uniqueSimilar = [...new Set(similar)].filter(w => w !== word);
            
            // æŒ‰ç›¸ä¼¼åº¦æ’åº
            return uniqueSimilar
                .map(w => ({ word: w, similarity: calculatePhoneticSimilarity(word, w) }))
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, 20)
                .map(item => item.word);
        }
        
        // ç”Ÿæˆç›´æ¥å˜å½¢
        function generateDirectVariations(word) {
            const variations = [];
            
            // è‹±ç¾æ‹¼å†™å·®å¼‚
            if (word.includes('ization')) {
                variations.push(word.replace('ization', 'isation'));
            }
            if (word.includes('isation')) {
                variations.push(word.replace('isation', 'ization'));
            }
            
            // å¤æ•°å½¢å¼
            if (word.endsWith('tion')) {
                variations.push(word + 's');
            }
            if (word.endsWith('ion')) {
                variations.push(word + 's');
            }
            
            // å½¢å®¹è¯å½¢å¼
            if (word.endsWith('tion')) {
                const base = word.slice(0, -4);
                variations.push(base + 'tional');
            }
            if (word.endsWith('ization')) {
                const base = word.slice(0, -8);
                variations.push(base + 'ize');
                variations.push(base + 'izing');
                variations.push(base + 'ized');
            }
            
            // è¯æ ¹å˜åŒ–
            if (word.startsWith('re')) {
                variations.push(word.slice(2)); // å»æ‰ re- å‰ç¼€
                variations.push('dis' + word.slice(2)); // dis- å‰ç¼€
                variations.push('un' + word.slice(2)); // un- å‰ç¼€
            }
            
            return variations.filter(v => v.length > 2);
        }
        
        // åŸºäºéŸ³éŸµæ¨¡å¼åŒ¹é…
        function findPhoneticMatches(word) {
            const matches = [];
            
            // ç›¸åŒç»“å°¾çš„è¯
            const endings = ['-ation', '-tion', '-sion', '-ization', '-isation', '-ism', '-ist', '-ity', '-ive', '-ous'];
            
            endings.forEach(ending => {
                const suffix = ending.slice(1); // å»æ‰ -
                if (word.endsWith(suffix)) {
                    const stem = word.slice(0, -suffix.length);
                    
                    // æŸ¥æ‰¾å…¶ä»–ä»¥ç›¸åŒè¯æ ¹å¼€å¤´çš„è¯
                    extendedVocabulary.forEach(vocabWord => {
                        if (vocabWord.startsWith(stem) && vocabWord !== word) {
                            matches.push(vocabWord);
                        }
                    });
                    
                    // æŸ¥æ‰¾å…¶ä»–ç›¸åŒç»“å°¾çš„è¯
                    extendedVocabulary.forEach(vocabWord => {
                        if (vocabWord.endsWith(suffix) && 
                            vocabWord !== word && 
                            Math.abs(vocabWord.length - word.length) <= 4) {
                            matches.push(vocabWord);
                        }
                    });
                }
            });
            
            return matches;
        }
        
        // æŸ¥æ‰¾è¯æ ¹åŒ¹é…
        function findRootMatches(word) {
            const matches = [];
            
            // æå–å¯èƒ½çš„è¯æ ¹
            let root = word;
            const prefixes = ['re', 'un', 'dis', 'pre', 'over', 'under', 'out', 'mis'];
            const suffixes = ['tion', 'sion', 'ation', 'ization', 'isation', 'ity', 'ive', 'ous', 'al', 'ic', 'ed', 'ing', 's'];
            
            // å»æ‰å‰ç¼€
            prefixes.forEach(prefix => {
                if (root.startsWith(prefix)) {
                    root = root.slice(prefix.length);
                }
            });
            
            // å»æ‰åç¼€
            suffixes.forEach(suffix => {
                if (root.endsWith(suffix)) {
                    root = root.slice(0, -suffix.length);
                }
            });
            
            // æŸ¥æ‰¾åŒ…å«ç›¸åŒè¯æ ¹çš„è¯
            if (root.length >= 3) {
                extendedVocabulary.forEach(vocabWord => {
                    if (vocabWord.includes(root) && vocabWord !== word) {
                        matches.push(vocabWord);
                    }
                });
            }
            
            return matches;
        }
        
        // æŸ¥æ‰¾éŸ³èŠ‚ç»“æ„ç›¸ä¼¼çš„è¯
        function findSyllableMatches(word) {
            const matches = [];
            const wordSyllables = generateSyllables(word);
            const wordSyllableCount = wordSyllables.length;
            
            extendedVocabulary.forEach(vocabWord => {
                if (vocabWord === word) return;
                
                const vocabSyllables = generateSyllables(vocabWord);
                const vocabSyllableCount = vocabSyllables.length;
                
                // éŸ³èŠ‚æ•°é‡ç›¸è¿‘
                if (Math.abs(wordSyllableCount - vocabSyllableCount) <= 1) {
                    // æ£€æŸ¥éŸ³èŠ‚ç»“æ„ç›¸ä¼¼åº¦
                    const syllableSimilarity = calculateSyllableSimilarity(wordSyllables, vocabSyllables);
                    if (syllableSimilarity > 0.3) {
                        matches.push(vocabWord);
                    }
                }
            });
            
            return matches;
        }
        
        // è®¡ç®—éŸ³èŠ‚ç›¸ä¼¼åº¦
        function calculateSyllableSimilarity(syllables1, syllables2) {
            let matchCount = 0;
            const maxLength = Math.max(syllables1.length, syllables2.length);
            
            for (let i = 0; i < Math.min(syllables1.length, syllables2.length); i++) {
                if (syllables1[i].toLowerCase() === syllables2[i].toLowerCase()) {
                    matchCount++;
                } else if (syllables1[i].toLowerCase().includes(syllables2[i].toLowerCase()) ||
                          syllables2[i].toLowerCase().includes(syllables1[i].toLowerCase())) {
                    matchCount += 0.5;
                }
            }
            
            return matchCount / maxLength;
        }
        
        // è®¡ç®—è¯­éŸ³ç›¸ä¼¼åº¦
        function calculatePhoneticSimilarity(word1, word2) {
            // åŸºäºå¤šä¸ªå› ç´ è®¡ç®—ç›¸ä¼¼åº¦
            let similarity = 0;
            
            // 1. è¯é•¿ç›¸ä¼¼åº¦
            const lengthSimilarity = 1 - Math.abs(word1.length - word2.length) / Math.max(word1.length, word2.length);
            similarity += lengthSimilarity * 0.2;
            
            // 2. å¼€å¤´ç›¸ä¼¼åº¦
            const prefixLength = Math.min(3, Math.min(word1.length, word2.length));
            let prefixMatch = 0;
            for (let i = 0; i < prefixLength; i++) {
                if (word1[i].toLowerCase() === word2[i].toLowerCase()) {
                    prefixMatch++;
                }
            }
            similarity += (prefixMatch / prefixLength) * 0.3;
            
            // 3. ç»“å°¾ç›¸ä¼¼åº¦
            const suffixLength = Math.min(4, Math.min(word1.length, word2.length));
            let suffixMatch = 0;
            for (let i = 0; i < suffixLength; i++) {
                const pos1 = word1.length - 1 - i;
                const pos2 = word2.length - 1 - i;
                if (word1[pos1].toLowerCase() === word2[pos2].toLowerCase()) {
                    suffixMatch++;
                }
            }
            similarity += (suffixMatch / suffixLength) * 0.3;
            
            // 4. ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦
            const editSimilarity = 1 - editDistance(word1, word2) / Math.max(word1.length, word2.length);
            similarity += editSimilarity * 0.2;
            
            return similarity;
        }

        // è®¡ç®—å•è¯ç›¸ä¼¼åº¦ - ä¿ç•™åŸæœ‰å‡½æ•°åä½†æ”¹è¿›ç®—æ³•
        function calculateSimilarity(word1, word2) {
            return calculatePhoneticSimilarity(word1, word2);
        }

        // è®¡ç®—ç¼–è¾‘è·ç¦»
        function editDistance(str1, str2) {
            const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
            
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    if (str1[i - 1] === str2[j - 1]) {
                        matrix[j][i] = matrix[j - 1][i - 1];
                    } else {
                        matrix[j][i] = Math.min(
                            matrix[j - 1][i - 1] + 1,
                            matrix[j][i - 1] + 1,
                            matrix[j - 1][i] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        // æ˜¾ç¤ºæœç´¢ç»“æœ
        function displayResults(word, data) {
            // æ˜¾ç¤ºéŸ³æ ‡ä¿¡æ¯
            const phoneticInfo = document.getElementById('phoneticInfo');
            const phoneticTranscription = document.getElementById('phoneticTranscription');
            
            phoneticTranscription.innerHTML = `
                <li><span class="bold">Modern IPA:</span> ${data.modern}</li>
                <li><span class="bold">Traditional IPA:</span> ${data.traditional}</li>
                <li><span class="bold">${data.syllables.length} syllables:</span>
                    <div class="syllables">
                        ${data.syllables.map(syllable => `"${syllable}"`).join(' + ')}
                    </div>
                </li>
            `;
            
            phoneticInfo.style.display = 'block';

            // æ˜¾ç¤ºç›¸ä¼¼å•è¯
            const similarWords = document.getElementById('similarWords');
            const wordGrid = document.getElementById('wordGrid');
            
            wordGrid.innerHTML = data.similar.map(similarWord => 
                `<div class="word-item" onclick="searchExample('${similarWord}')">${similarWord}</div>`
            ).join('');
            
            similarWords.style.display = 'block';
        }

        // æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('searchInput').disabled = show;
            document.querySelector('.search-btn').disabled = show;
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        // éšè—é”™è¯¯ä¿¡æ¯
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // ç¤ºä¾‹æœç´¢
        function searchExample(word) {
            document.getElementById('searchInput').value = word;
            updateUrl(word); // åŒæ—¶æ›´æ–°URL
            searchSimilarWords();
        }

        // å›è½¦æœç´¢
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchSimilarWords();
            }
        });

        // URLå‚æ•°å¤„ç†
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // æ›´æ–°URL
        function updateUrl(word) {
            const newUrl = window.location.origin + window.location.pathname + '?w=' + encodeURIComponent(word);
            window.history.pushState({word: word}, '', newUrl);
        }

        // ä»URLå‚æ•°è‡ªåŠ¨æœç´¢
        function searchFromUrl() {
            const wordFromUrl = getUrlParameter('w');
            if (wordFromUrl) {
                document.getElementById('searchInput').value = wordFromUrl;
                searchSimilarWords();
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        window.addEventListener('load', function() {
            // å…ˆæ£€æŸ¥URLå‚æ•°
            searchFromUrl();
            // èšç„¦è¾“å…¥æ¡†
            document.getElementById('searchInput').focus();
        });

        // å¤„ç†æµè§ˆå™¨å‰è¿›åé€€
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.word) {
                document.getElementById('searchInput').value = event.state.word;
                searchSimilarWords();
            } else {
                // æ¸…ç©ºæœç´¢ç»“æœ
                document.getElementById('phoneticInfo').style.display = 'none';
                document.getElementById('similarWords').style.display = 'none';
                document.getElementById('searchInput').value = '';
            }
        });
    </script>
</body>
</html>
